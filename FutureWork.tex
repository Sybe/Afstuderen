In this section we discuss improvements that can be made for better results. In the previous section we already discussed the possibility of different semantics. This is also future work, but is written in a separate section.

\subsection{Canonization}

\subsection{Reordering}
The current implementation is not compatible with the reordering algorithms. All algorithms will probably have to be changed somehow. In the current implementation it is assumed that on the top there is a set of LDD nodes, and from a certain level only DDD nodes exist. With reordering this could be mixed, so algorithms can not rely on this any more. A special case will again be the minus function. It is now done by recreating DBMs from the DDD. This can be done, as the nodes are ordered in the same way as the DBM. When reorderings are used this is not trivial any more. It will need to be explicitly stored which variable is on which level. For the different semantics that we introduced in section \ref{section:new-semantics}, a similar problem will occur. We suggested a minus function using the complement. For zones the complement is well defined, as there is a $\infty$ value representing the most upper- and lower-bounds of possible values. For discrete variables this is not directly clear. 
Another option for reordering, which will probably solve some of the problems with the minus function would be reordering, but keeping the discrete and the zone parts separated. The discrete part could use the normal reordering algorithms. As the matrices for the zone variables are completely filled, the reordering algorithms can not do something useful on that level. Here experiments with manual reorderings can be tried. Now the standard ordering of the DBMs is used. It might be that having both bounds on a pair of clocks together gives better results, or maybe even other orderings.

\subsection{Sparser Dependency Matrix}
The dependency matrices are densely filled. We already discussed the problems in section \ref{subsec:matrices}. There are some solutions that can improve this. Smaller transition groups can be created, maybe even splitting the discrete part and the timed part of a transition. This would also make that the zone part of the matrix would not need to be completely filled. The discrete transition would only need access to the zone parts on which bounds are calculated. The timed transitions would need all zone variables, but can leave discrete variables out which do not imply clock bounds. Another option that needs more work, is also filling the may-write matrices. The current code parsing that generates the matrices is not powerful enough to make a difference between may- and must-write variables. On this level also improvements can be made. The parts of the matrices for the zone variables are always filled, as the change of a single clock can have an impact on much of the DBM. We did not check however if an analysis can be done that finds fields which are not changed, or do not need to be read in a transition. A better analysis of the changes in DBMs can lead to sparser matrices on the zone variable side. The final improvement can be made for arrays. If the current implementation sees that a field from an array is read or written, then all fields in the array get a read or write dependency. It should be possible to only have dependencies for the fields that are actually read or written.

\subsection{Multi-Core}
The DDD library is built in the Sylvan framework which allows for multi-threaded decision diagrams. The DDD library is not suited for multi-threading however. For the most operations this will only need some small adaptations. The biggest problem is in the minus operation. This uses the DBM library. This part is not completely thread-safe. We expect this problem to be in the coupling between the DDD and the DBM library, in the DBM part no objects can be shared between threads. We expect that making the DDD part suitable for multi-threading will give much better time results.

\subsection{Animo Model Compatibility}
The project started to find a solution to model-check \animo{} models. This part has not succeeded. \animo{} models use a \uppaal{} feature that is not supported by opaal, using clock bounds on input channels. The problem why this can not be fixed directly is in the unrolling of the transitions in the next-state function. Adding the clock constraints on any of the input channels can lead to an empty DBM, in such cases the transition would not be returned. The semantics would however create the transitions, but not synchronize with the location leading to the empty DBM. To ensure that in such cases all possible transitions that can happen will be returned, a unroll of all possible combinations of synchronizing transitions would be needed. This will need a redesign of that part of the successor generator. If this functionality is added to opaal, all \animo{} models should be compatible with opaal, and thus our symbolic solution.

\subsection{Subsumption}
The subsumption check that is included in the multi-core explicit-state back-end in \ltsmin{} is not implemented in the DDD library. This can be implemented as a DDD operation, with the implication operator and the apply function. A check $a \subseteq b$ will result in true if $b \implies a$ returns true. If a canonical form is used as well, the result will be only a true node, or a single path of $(\infty,<)$ nodes, depending on the possibility of skipping levels. This can limit the number of states added to the current set in the state algorithm, thus reducing the number of next-state calls needed.
