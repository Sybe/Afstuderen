In this section we discuss improvements that can be made for better results. In the previous section we already discussed the possibility of different semantics. This is also future work, but is written in a separate section.

\subsection{Canonization}
The DDD package does not use any canonical form. This means that some operations like equality and emptiness become less trivial. They can however still be done. The diagrams are ordered and locally reduced. The resulting state-vectors that the language module produces are also path-reduced. Most operators do not preserve this path-reducedness, so most diagrams will not be path-reduced. 

We can implement two types of reduced DDDs. A DDD that is only path-reduced can be called semi-canonical~\cite{ddds}. This means that a tautology and a unsatisfiable expression can only be represented by a true or false node. This will make the checking for an empty DDD trivial, the DDD is only empty if the top node is a false node. We also defined full reducedness as a DDD that is tight and saturated, and has no disjunctive vertices. This fully reduced version is assumed to be canonical. A canonical DDD will change the equality test in a simple pointer comparison of the top nodes.
Several algorithms to reach a reduced form are known~\cite{ddd-mt-98}.

The canonical forms are not needed at all times, only for some functions that need the specific form. Therefore we can choose to not have a canonical form at all times. One can choose to canonize the DDD after each operation, or to do this only before operations that actually need this form. The first option will have much canonization calls, where the second option will have less. The first option however, might have a DDD that is in all cases closer to the canonical form, so canonization might take less time. The semi-canonical form can also be used for emptiness checks, as the fully reduced diagram is not needed there. To get optimal results we need to find out what is the best option.

\subsection{Reordering}
The current implementation is not compatible with the reordering algorithms. All algorithms will probably have to be changed somehow. In the current implementation it is assumed that on the top there is a set of LDD nodes, and from a certain level only DDD nodes exist. With reordering this could be mixed, so algorithms can not rely on this any more. A special case will again be the minus function. It is now done by recreating DBMs from the DDD. This can be done, as the nodes are ordered in the same way as the DBM. When reorderings are used this is not trivial any more. It will need to be explicitly stored which variable is on which level. For the different semantics that we introduced in section \ref{section:new-semantics}, a similar problem will occur. We suggested a minus function using the complement. For zones the complement is well defined, as there is a $\infty$ value representing the most upper- and lower-bounds of possible values. For discrete variables this is not directly clear.
 
Another option for reordering, which will probably solve some of the problems with the minus function would be reordering, but keeping the discrete and the zone parts separated. The discrete part could use the normal reordering algorithms. As the matrices for the zone variables are completely filled, the reordering algorithms can not do something useful on that level. Here experiments with manual reorderings can be tried. Now the standard ordering of the DBMs is used. It might be that having both bounds on a pair of clocks together gives better results, or maybe even other orderings.

\subsection{Sparser Dependency Matrix}
The dependency matrices are densely filled. We already discussed the problems in section \ref{subsec:matrices}. There are some solutions that can improve this. Smaller transition groups can be created, maybe even splitting the discrete part and the timed part of a transition. This would also make that the zone part of the matrix would not need to be completely filled. The discrete transition would only need access to the zone parts on which bounds are calculated. The timed transitions would need all zone variables, but can leave discrete variables out which do not imply clock bounds. Another option that needs more work, is also filling the may-write matrices. The current code parsing that generates the matrices is not powerful enough to make a difference between may- and must-write variables. On this level also improvements can be made. The parts of the matrices for the zone variables are always filled, as the change of a single clock can have an impact on much of the DBM. We did not check however if an analysis can be done that finds fields which are not changed, or do not need to be read in a transition. A better analysis of the changes in DBMs can lead to sparser matrices on the zone variable side. The final improvement can be made for arrays. If the current implementation sees that a field from an array is read or written, then all fields in the array get a read or write dependency. It should be possible to only have dependencies for the fields that are actually read or written.

\subsection{Multi-Core}
The DDD library is built in the Sylvan framework which allows for multi-threaded decision diagrams. The DDD library is not suited for multi-threading however. For the most operations this will only need some small adaptations. The biggest problem is in the minus operation. This uses the DBM library. This part is not completely thread-safe. We expect this problem to be in the coupling between the DDD and the DBM library, in the DBM part no objects can be shared between threads. We expect that making the DDD part suitable for multi-threading will give much better time results.

\subsection{Animo Model Compatibility}
The project started to find a solution to model-check \animo{} models. This part has not succeeded. \animo{} models use a \uppaal{} feature that is not supported by opaal, using clock bounds on input channels. The problem why this can not be fixed directly is in the unrolling of the transitions in the next-state function. Adding the clock constraints on any of the input channels can lead to an empty DBM, in such cases the transition would not be returned. The semantics would however create the transitions, but not synchronize with the location leading to the empty DBM. To ensure that in such cases all possible transitions that can happen will be returned, a unroll of all possible combinations of synchronizing transitions would be needed. This will need a redesign of that part of the successor generator. If this functionality is added to opaal, all \animo{} models should be compatible with opaal, and thus our symbolic solution.

\subsection{Subsumption}
The subsumption check that is included in the multi-core explicit-state back-end in \ltsmin{} is not implemented in the DDD library. This can be implemented as a DDD operation, with the implication operator and the apply function. A check $a \subseteq b$ will result in true if $b \implies a$ returns true. If a canonical form is used as well, the result will be only a true node, or a single path of $(\infty,<)$ nodes, depending on the possibility of skipping levels. This can limit the number of states added to the current set in the state algorithm, thus reducing the number of next-state calls needed. The most obvious subsumption check would be the check that a newly discovered zone is subsumed by the already visited state-space. It can however also be turned around, check if the visited state-space is subsumed by the newly discovered zone. In such a case the zone in the state space can be replaced by this new zone, such that the union function is not needed, this will not reduce the next-state calls however.

\subsection{Checking Properties}
The model-checker that we have created is only suited for state-space generation. It is not suited for property checking. One extra function is needed to use the \ltsmin{} mu-calculus checker, which can also check CTL* formulas. The DDD library needs to be extended with a relprev function, which returns the predecessors given a set of states and a relation. This will only result in a discrete model-checker. \ltsmin{} is not suited for timing properties. Some timing properties can be checked by extending the model with an extra automaton.
